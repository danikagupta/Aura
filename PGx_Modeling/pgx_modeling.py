# -*- coding: utf-8 -*-
"""PGX_modeling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Tmisw5D3hWyQ7SVDicKMB2IyEpQD_ats
"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
from sklearn.model_selection import cross_validate, StratifiedKFold
from sklearn.preprocessing import OneHotEncoder, LabelEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.impute import SimpleImputer
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier, HistGradientBoostingClassifier
from sklearn.metrics import make_scorer, accuracy_score, precision_score, recall_score, f1_score, roc_auc_score

# ==========================================
# CONFIGURATION
# ==========================================
#FILE_PATH = '/content/drive/Shareddrives/Danika-work5/LLM_Extract/Davidson/pgx_standardized_data.csv'  # Update this to your file path
#FILE_PATH = '/content/drive/Shareddrives/Danika-work5/LLM_Extract/Davidson/pgx_gemini_standardized_datacsv'  # Update this to your file path
#FILE_PATH = '/content/drive/Shareddrives/Danika-work5/LLM_Extract/Davidson/pgx_merged_standardized_data.csv'  # Update this to your file path
#FILE_PATH = '/content/drive/Shareddrives/Danika-work5/LLM_Extract/Davidson//pgx_soft_deduplicated_ensemble.csv'  # Update this to your file path
FILE_PATH = '/content/drive/Shareddrives/Danika-work5/LLM_Extract/Davidson/pgx_aggressive_ground_truth.csv'  # Update this to your file path

def run_actionability_ml(path):
    # 1. Load Data
    df = pd.read_csv(path)

    # 2. Select Features and Target
    # We use the cleaned columns from the standardization step
    features = ['gene', 'medication', 'standardized_alleles']
    target = 'actionability'

    # Filter out rows where target is missing (should be 0 in your set)
    df = df.dropna(subset=[target])

    X = df[features].copy()
    y = LabelEncoder().fit_transform(df[target]) # Yes -> 1, No -> 0

    # Fill NaNs with 'Unknown' string so the encoder can process them
    X = X.fillna('Unknown')

    # 3. Define Preprocessing
    # We use OneHotEncoding for the categorical strings
    # handle_unknown='ignore' allows the model to see new drugs/genes later
    categorical_transformer = Pipeline(steps=[
        ('onehot', OneHotEncoder(handle_unknown='ignore', sparse_output=False))
    ])

    preprocessor = ColumnTransformer(
        transformers=[
            ('cat', categorical_transformer, features)
        ])

    # 4. Define Models to Test
    models = {
        "Logistic Regression": LogisticRegression(max_iter=1000, class_weight='balanced'),
        "Random Forest": RandomForestClassifier(n_estimators=100, class_weight='balanced', n_jobs=-1),
        "Gradient Boosting": HistGradientBoostingClassifier() # Handles sparse data well
    }

    # 5. Define Evaluation Metrics
    scoring = {
        'accuracy': 'accuracy',
        'precision': 'precision',
        'recall': 'recall',
        'f1': 'f1',
        'roc_auc': 'roc_auc'
    }

    results = []
    skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)

    print(f"Starting 5-Fold Cross-Validation on {len(df)} records...")
    print("-" * 60)

    for name, model in models.items():
        print(f"Training {name}...")

        # Create pipeline
        clf = Pipeline(steps=[('preprocessor', preprocessor),
                              ('classifier', model)])

        # Run Cross Validation
        cv_results = cross_validate(clf, X, y, cv=skf, scoring=scoring)

        # Aggregate Results
        results.append({
            "Algorithm": name,
            "Accuracy": cv_results['test_accuracy'].mean(),
            "Precision": cv_results['test_precision'].mean(),
            "Recall": cv_results['test_recall'].mean(),
            "F1-Score": cv_results['test_f1'].mean(),
            "ROC-AUC": cv_results['test_roc_auc'].mean()
        })

    # 6. Display Performance Spectrum
    results_df = pd.DataFrame(results).sort_values(by="F1-Score", ascending=False)

    print("\n" + "="*70)
    print("ACTIONABILITY CLASSIFICATION PERFORMANCE (5-FOLD CV)")
    print("="*70)
    print(results_df.to_string(index=False, float_format=lambda x: f"{x:.4f}"))
    print("="*70)
    print("\nInterpretation:")
    print("- ROC-AUC: Ability to distinguish between Actionable and Non-Actionable (0.5 is random).")
    print("- Recall: Percentage of truly Actionable cases the model caught.")
    print("- Precision: How many 'Actionable' flags were actually correct.")

# Execute
run_actionability_ml(FILE_PATH)

import pandas as pd
import numpy as np
import re
from sklearn.model_selection import StratifiedKFold, cross_validate
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import OneHotEncoder, LabelEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.metrics import classification_report

# ==========================================
# CONFIGURATION
# ==========================================
#FILE_PATH = 'pgx_standardized_data.csv'
#FILE_PATH = '/content/drive/Shareddrives/Danika-work5/LLM_Extract/Davidson/pgx_standardized_data.csv'  # Update this to your file path
#FILE_PATH = '/content/drive/Shareddrives/Danika-work5/LLM_Extract/Davidson/pgx_gemini_standardized_datacsv'  # Update this to your file path
#FILE_PATH = '/content/drive/Shareddrives/Danika-work5/LLM_Extract/Davidson/pgx_merged_standardized_data.csv'  # Update this to your file path
FILE_PATH = '/content/drive/Shareddrives/Danika-work5/LLM_Extract/Davidson/pgx_aggressive_ground_truth.csv'  # Update this to your file path


def run_outcome_prediction_ml(path):
    # 1. Load Data
    print(f"Loading {path}...")
    df = pd.read_csv(path)

    # 2. NLP Categorization (Simulating extraction into discrete labels)
    # Define clinical categories and their associated keywords
    categories = {
        'ADR_Toxicity': ['adverse', 'side effect', 'toxicity', 'reaction', 'rash', 'nausea', 'weight gain', 'syndrome'],
        'Efficacy_Response': ['response', 'efficacy', 'effective', 'remission', 'improvement', 'responder', 'benefit'],
        'Metabolism_PK': ['concentration', 'clearance', 'pk', 'plasma', 'level', 'auc', 'metabolism', 'half-life'],
        'Dosing': ['dose', 'dosage', 'titration', 'mg', 'reduction', 'escalation']
    }

    def categorize_outcome(text):
        if pd.isna(text): return None
        text = str(text).lower()
        for cat, keywords in categories.items():
            if any(k in text for k in keywords):
                return cat
        return 'Other/Unspecified'

    print("Categorizing unstructured outcome text...")
    df['outcome_category'] = df['outcome'].apply(categorize_outcome)

    # 3. Filter for records that have both genetic info and a categorized outcome
    # We focus on rows with standardized_alleles for biological accuracy
    df_ml = df.dropna(subset=['standardized_alleles', 'outcome_category', 'medication'])
    df_ml = df_ml[df_ml['outcome_category'] != 'Other/Unspecified'] # Focus on known clinical classes

    print(f"Cleaned dataset size for Task 2: {len(df_ml)} records")
    print("Class distribution:")
    print(df_ml['outcome_category'].value_counts())

    # 4. Feature Selection
    features = ['gene', 'medication', 'standardized_alleles']
    X = df_ml[features].fillna('Unknown')

    # Target Encoding
    le = LabelEncoder()
    y = le.fit_transform(df_ml['outcome_category'])
    class_names = le.classes_

    # 5. ML Pipeline
    preprocessor = ColumnTransformer(
        transformers=[
            ('cat', OneHotEncoder(handle_unknown='ignore', sparse_output=False), features)
        ])

    clf_pipeline = Pipeline(steps=[
        ('preprocessor', preprocessor),
        ('classifier', RandomForestClassifier(n_estimators=100, class_weight='balanced', random_state=42))
    ])

    # 6. 5-Fold Cross-Validation
    skf = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)
    scoring = ['accuracy', 'f1_macro', 'precision_macro', 'recall_macro']

    print("\nRunning 5-Fold Cross-Validation for Multi-class Prediction...")
    cv_results = cross_validate(clf_pipeline, X, y, cv=skf, scoring=scoring)

    # 7. Final Metrics Output
    print("\n" + "="*70)
    print("TASK 2: GENOTYPE-TO-OUTCOME CATEGORY PERFORMANCE")
    print("="*70)
    print(f"{'Metric':<20} | {'Mean Score (5-Fold CV)':<20}")
    print("-" * 70)
    print(f"{'Accuracy':<20} | {cv_results['test_accuracy'].mean():.4f}")
    print(f"{'Precision (Macro)':<20} | {cv_results['test_precision_macro'].mean():.4f}")
    print(f"{'Recall (Macro)':<20} | {cv_results['test_recall_macro'].mean():.4f}")
    print(f"{'F1-Score (Macro)':<20} | {cv_results['test_f1_macro'].mean():.4f}")
    print("="*70)

    print("\nClinical Utility:")
    print(f"This model predicts which type of clinical outcome (e.g., ADR vs PK) a patient is")
    print(f"likely to experience based on their PGx profile for a specific medication.")

# Execute the analysis
run_outcome_prediction_ml(FILE_PATH)